For user convenience, Agda's standard library has accumulated a set of
equality-manipulating combinators of varying arities (Section~\ref{sec:nary2})
as well as a type-level compositional DSL to write clean types involving
indexed families of arity exactly one (Section~\ref{sec:unarycombinators}).
None of these solutions scale well.

\section{N-ary Combinators... for N up to 2}\label{sec:nary2}

Agda's standard library relies on propositional equality defined as
a level polymorphic inductive family with one constructor \AIC{refl}.

\ExecuteMetaData[StateOfTheArt.tex]{equality}

As one would expect from a notion of equality, it is congruent (i.e.
for any function equal inputs yield equal outputs) and substitutive
(i.e. equals behave the same with respect to predicates). Concretely
this means we can write the two following functions by dependent
pattern-matching on the equality proof:

\ExecuteMetaData[StateOfTheArt.tex]{cong}
\ExecuteMetaData[StateOfTheArt.tex]{subst}

However we quickly realise that it is convenient to be able to use
congruence for functions which take more than one argument and
substitution for at least binary relations. The standard library
provides binary versions of both of these functions:

\ExecuteMetaData[StateOfTheArt.tex]{cong2}
\ExecuteMetaData[StateOfTheArt.tex]{subst2}

If we want to go beyond arity two however we are left to either define
our own ternary, quaternary, etc. versions of \AF{cong} and \AF{subst}
or awkwardly chaining the ones with a lower arity to slowly massage
the expression at hand into the shape we want. Both of these solutions
are unsatisfactory.

\paragraph{Wish} We would like to define once and for all two functions
\AF{congₙ} and \AF{substₙ} of respective types (pseudocode):

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{congₙ} : & (\AB{f} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B}) →\\
               & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
               & \AB{f} \AB{a₁} ⋯ \AB{aₙ} \AD{≡} \AB{f} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}
\medskip

\noindent\begin{tabular}{@{}l@{~}l}
  \AF{substₙ} : & (\AB{R} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AF{Set} \AB{r}) →\\
                & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
                & \AB{R} \AB{a₁} ⋯ \AB{aₙ} → \AB{R} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}

\section{Invariant Respecting Programs}

A key feature of dependently typed languages is the ability to enforce
strong invariants in inductive families. As soon as the programmer starts
baking in these constraints, they need to write constraints-respecting
programs. Although a lot of programs are index-preserving, users need
to be painfully explicit about the index being threaded all across the
function's type.

\subsection{Working With Indexed Families}\label{sec:unarycombinators}

The standard library defines a set of handy combinators to talk about
indexed families without having to manipulate their index explicitly.
These form a compositional type-level DSL: each combinator has a very
specific semantics and putting them together builds an overall meaning.
A typical expression built using this DSL follows a fairly simple schema:
a combinator acting as a quantifier for the index surrounding a combination
of pointwise liftings of common type constructors.



The pointwise liftings of common type constructors mean the index is
threaded but we also have specialised combinators which either adjust
locally the value of the index, or quantify over it. This empowers
us to write lighter types which focus on the important predicates at
hand.

Before we can talk about concrete indexed families, describe these
various combinators, and demonstrate their usefulness, we need to
introduce the data the families will be indexed over. We pick \AD{List}
the level polymorphic type of lists parametrised by the type of their
elements as our running example.

\ExecuteMetaData[StateOfTheArt.tex]{list}

The most straightforward non-trivial indexed family we can define over
\AD{List} is the predicate lifting \AF{All} which ensures that a given
predicate \AB{P} holds of all the elements of a list. It has two
constructors which each bear the same name as their counterparts in the
underlying data: nil (\AIC{[]}) is a proof that all the elements in the
empty list satisfy \AB{P} and cons (\AIC{\_::\_}) is a proof that \AB{P}
holds of all the elements of a non-empty list if it holds of its head
and of all the elements in its tail.

\ExecuteMetaData[StateOfTheArt.tex]{all}

\subsubsection{Quantifiers}

We have two types of quantifiers: existential and universal. As they are
meant to \emph{surround} the indexed expression they are acting upon, we
define them as essentially pairs of brackets. The opening one is systematically
decorated with a mnemonic symbol: \AF{∃} for existential quantification,
\AF{Π} for explicit dependent quantification and \AF{∀} for implicit
universal quantification. Additionally we use chevrons for existential
quantifiers and square brackets for universal ones, recalling the operators
diamond and box of modal logic.

\paragraph{Existential Quantifier} In type theory, existential quantifiers
are represented as dependent pairs. We introduce \AF{Σ}, a record type of
dependent pairs. They can be constructed using \AIC{\_,\_} and we can project
out the first and second component by using \ARF{proj₁} and \ARF{proj₂}
respectively.

\ExecuteMetaData[StateOfTheArt.tex]{sigma}

The existential quantifier for indexed families is defined as a special
case of \AF{Σ} which takes the index \AF{Set} implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{exists}

Using \AF{∃⟨\_⟩} we can write our first statement about an indexed family:
{(\AF{All} \AB{P})} is always satisfiable. That is to say that we can always
find a list (the empty one) for which it holds.

\ExecuteMetaData[StateOfTheArt.tex]{satisfiable}

\paragraph{Universal Quantifiers} The pendant of existential quantification
is universal quantification. In type theory this corresponds to a dependent
function space. Here we have room for variations and we can consider both
the explicit (\AF{Π[\_]}) \emph{and} the implicit (\AF{∀[\_]}) universal
quantifiers.

\ExecuteMetaData[StateOfTheArt.tex]{universal}
\ExecuteMetaData[StateOfTheArt.tex]{iuniversal}

Provided that a proposition holds of any value, we can prove it will hold
of any list of values by induction on such a list. Because we perform
induction on the list it is convenient to take it as an explicit argument
whereas the proof itself can take its argument implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{replicate}

\subsubsection{Pointwise Liftings}

Pointwise liftings for an index type \AB{I} are operators turning a type
constructor on \AF{Set}s into one acting on \AB{I}-indexed families by
threading the index. They are meant to be used partially applied so that
both their inputs and their output are \AB{I}-indexed, hence the mismatch
between their arity and the number of places for their arguments.

\paragraph{Implication} We start with the most used of all: implication
i.e. functions from proofs of one predicate to proofs of another.
\ExecuteMetaData[StateOfTheArt.tex]{implies}

The combinator \AF{\_⇒\_} associates to the right just like the type
constructor for functions does. We can write the analogue of sequential
application for applicative functors~\cite{DBLP:journals/jfp/McbrideP08}
like so:
\ExecuteMetaData[StateOfTheArt.tex]{ap}

\paragraph{Conjunction} To state that the conjunction of two predicates hold
we can use the pointwise lifting of pairing.

\ExecuteMetaData[StateOfTheArt.tex]{conjunction}

This enables to write functions which return more than one result. We can
for instance write the type of \AF{unzip}, the proof that if the conjunction
of \AB{P} and \AB{Q} holds of all the elements of a given list then both
\AB{P} and \AB{Q} in isolation hold of all of that list's elements.
\ExecuteMetaData[StateOfTheArt.tex]{unzip}

\paragraph{Negation}\todo{Pick pure vs distrib}

\ExecuteMetaData[StateOfTheArt.tex]{negation}
\ExecuteMetaData[StateOfTheArt.tex]{pure}
\ExecuteMetaData[StateOfTheArt.tex]{distrib}

\subsubsection{Adjustments to The Ambient Index}

Threading the index is only the least invasive of the modes of action
available to us. But we can also more actively interact with the ambient
index either by ignoring it completely, adjusting it using a function
or overwriting it entirely. We won't detail the last option as, as always,
overwriting is adjusting with a constant function.

\paragraph{Constant} Although we manipulate indexed families, some of
our function's arguments or its result may not depend on the index.
The \AF{const}ant indexed family is precisely what we need to represent
these cases.

\ExecuteMetaData[StateOfTheArt.tex]{const}

The erasure function taking a proof that \AB{P} holds of all a list's
elements to a list of pairs of elements and proofs that \AB{P} holds
of them is an instance where the return type is constant in the index.

\ExecuteMetaData[StateOfTheArt.tex]{toList}

\paragraph{Update} On the other end of the spectrum, we have operations
which update the ambient index using an abitrary function. The notation
\AF{\_⊢\_} is inspired by the convention in type theory to consider that
proofs in sequent calculus are written in an ambient context and that we
may use a turnstyle to describe the addition of newly-bound variables to
it.

\ExecuteMetaData[StateOfTheArt.tex]{update}

Stating that a function is compatible with \AF{All} is a typical use case
of such a combinator. If the function at hand is called \AF{f} then the
convention in the standard library is to call such a proof \AF{f⁺} as it
makes \AF{f} appear in the conclusion. We pick \AF{concat} (whose classic
definition is left out) in this concrete example.

\ExecuteMetaData[StateOfTheArt.tex]{join}

\subsection{Working With Multiple Indices}

We started by showing both the type and the implementation of each of our
examples. Although convenient at first to build an understanding of which
arguments are explicit and which ones are implicit, we are in the end only
interested in the way combinators let us write types. From now on, we
focus on the types and only the types of our examples.

The combinators presented earlier are all available in the standard library.
They work really well for unary predicates. Unfortunately they do not scale
beyond that. Meaning that if we are manipulating binary relations for
instance we have to partially apply the relations in question before we can
use our usual unary combinators. This leads to cluttered types which are not
much better than their fully expanded counterparts. For instance, assuming
that \AF{\_≤\_} is the usual order on natural numbers and \AF{\_≥\_} its
converse, to state that \AF{\_≤\_} is antisymmetric we have to write:

\ExecuteMetaData[StateOfTheArt.tex]{brokenantisym}

Ideally we could have used combinators similar to the ones for unary predicates
and have simply written:

\ExecuteMetaData[Examples.tex]{antisym}

We could duplicate the definitions for unary predicates and have equivalent
combinators for binary relations however this will create two new issues.
First, the day we need a library for ternary relations we will have triplicated
the initial work. Second, we would have two sets of definitions with identical
names meaning they cannot be both imported in the same module without clashing
thus forcing users to manually disambiguate each use site.

\paragraph{Wish} We would like to define once and for all n-ary quantifiers,
pointwise lifting of common type constructors, and adjustment functions.

\section{Plan}

\paragraph{Reified Types} We need to come up with a representation of n-ary
functions which is as general as possible: the domains should be allowed to
be different types, even types defined at different levels.

\paragraph{Semantics} We need to give a semantics taking a reified type and
computing its meaning as a \AF{Set} at some level which will also need to
be computed.

\paragraph{Invertible} The representation and its semantics should be unifier
friendly. That is to say that if using a combinators yields a constraint of
the form ``this type should be result of evaluating the representation of an
n-ary function type'' then Agda should be able to reconstruct the
representation and discharge the constraints without any outside help.

\section{Getting Acquainted With the Unifier}

It is important to build an understanding of the way the unifier proceeds
to be able to write combinators usable with minimal user input.

Forgetting for a moment about level polymorphism, let us look at the first
wrong turn one may take. The type of an arbitrary function may be understood
as a list of \AF{Set}s (the successive domains) paired with a \AF{Set} (the
codomain). We can then compute the function's actual type as a \AF{foldr} on
the list.

\ExecuteMetaData[Broken.tex]{function}
\ExecuteMetaData[Broken.tex]{sem}



