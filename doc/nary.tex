For user convenience, Agda's standard library has accumulated a set of
equality-manipulating combinators of varying arities (Section~\ref{sec:nary2})
as well as a type-level compositional DSL to write clean types involving
indexed families of arity exactly one (Section~\ref{sec:unarycombinators}).
None of these solutions scale well.

\section{N-ary combinators... for N up to 2}\label{sec:nary2}

Agda's standard library relies on propositional equality defined as
a level polymorphic inductive family with one constructor \AIC{refl}.

\ExecuteMetaData[StateOfTheArt.tex]{equality}

As one would expect from a notion of equality, it is congruent (i.e.
for any function equal inputs yield equal outputs) and substitutive
(i.e. equals behave the same with respect to predicates). Concretely
this means we can write the two following functions by dependent
pattern-matching on the equality proof:

\ExecuteMetaData[StateOfTheArt.tex]{cong}
\ExecuteMetaData[StateOfTheArt.tex]{subst}

However we quickly realise that it is convenient to be able to use
congruence for functions which take more than one argument and
substitution for at least binary relations. The standard library
provides binary versions of both of these functions:

\ExecuteMetaData[StateOfTheArt.tex]{cong2}
\ExecuteMetaData[StateOfTheArt.tex]{subst2}

If we want to go beyond arity two however we are left to either define
our own ternary, quaternary, etc. versions of \AF{cong} and \AF{subst}
or awkwardly chaining the ones with a lower arity to slowly massage
the expression at hand into the shape we want. Both of these solutions
are unsatisfactory.

\paragraph{Wish} We would like to define once and for all two functions
\AF{congₙ} and \AF{substₙ} of respective types (pseudocode):

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{congₙ} : & (\AB{f} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B}) →\\
               & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
               & \AB{f} \AB{a₁} ⋯ \AB{aₙ} \AD{≡} \AB{f} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}
\medskip

\noindent\begin{tabular}{@{}l@{~}l}
  \AF{substₙ} : & (\AB{R} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AF{Set} \AB{r}) →\\
                & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
                & \AB{R} \AB{a₁} ⋯ \AB{aₙ} → \AB{R} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}

\section{Invariant Respecting Programs}

A key feature of dependently typed languages is the ability to enforce
strong invariants in inductive families. As soon as the programmer starts
baking in these constraints, they need to write constraints-respecting
programs. Although a lot of programs are index-preserving, users need
to be painfully explicit about the index being threaded all across the
function's type.

\subsection{Working With Indexed Families}\label{sec:unarycombinators}

The standard library defines a set of handy combinators to talk about
indexed families without having to manipulate their index explicitly.
The pointwise lifting of common type constructors means the index is
threaded but we also have specialised combinators which either adjust
locally the value of the index, or quantify over it. This empowers
us to write lighter types which focus on the important predicates at
hand.

Before we can talk about concrete indexed families, describe these
various combinators, and demonstrate their usefulness, we need to
introduce the data the families will be indexed over. We pick \AD{List}
the level polymorphic type of lists parametrised by the type of their
elements as our running example.

\ExecuteMetaData[StateOfTheArt.tex]{list}

The most straightforward non-trivial indexed family we can define over
\AD{List} is the predicate lifting \AF{All} which ensures that a given
predicate \AB{P} holds of all the elements of a list. It has two
constructors which each bear the same name as their counterparts in the
underlying data: nil (\AIC{[]}) is a proof that all the elements in the
empty list satisfy \AB{P} and cons (\AIC{\_::\_}) is a proof that \AB{P}
holds of all the elements of a non-empty list if it holds of its head
and of all the elements in its tail.

\ExecuteMetaData[StateOfTheArt.tex]{all}

\paragraph{Existential Quantifier} In type theory, existential quantifiers
are represented as dependent pairs. We introduce \AF{Σ}, a record type of
dependent pairs. They can be constructed using \AIC{\_,\_} and we can project
out the first and second component by using \ARF{proj₁} and \ARF{proj₂}
respectively.

\ExecuteMetaData[StateOfTheArt.tex]{sigma}

The existential quantifier for indexed families is defined as a special
case of \AF{Σ} which takes the index \AF{Set} implicitly.\todo{More ⟨⟩}

\ExecuteMetaData[StateOfTheArt.tex]{exists}

Using \AF{∃⟨\_⟩} we can write our first statement about an indexed family:
{(\AF{All} \AB{P})} is always satisfiable. That is to say that we can always
find a list (the empty one) for which it holds.

\ExecuteMetaData[StateOfTheArt.tex]{satisfiable}

\paragraph{Universal Quantifiers} The pendant of existential quantification
is universal quantification. In type theory this corresponds to a dependent
function space. Here we have room for variations and we can consider both
the explicit (\AF{Π[\_]}) \emph{and} the implicit (\AF{∀[\_]}) universal
quantifiers.\todo{More []}

\ExecuteMetaData[StateOfTheArt.tex]{universal}
\ExecuteMetaData[StateOfTheArt.tex]{iuniversal}

Provided that a proposition holds of any value, we can prove it will hold
of any list of values by induction on such a list. Because we perform
induction on the list it is convenient to take it as an explicit argument
whereas the proof itself can take its argument implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{replicate}

\paragraph{Pointwise Implication}
\todo{Binary Ternary}
\ExecuteMetaData[StateOfTheArt.tex]{implies}
\ExecuteMetaData[StateOfTheArt.tex]{ap}

\paragraph{Pointwise Negation}

\ExecuteMetaData[StateOfTheArt.tex]{negation}
\ExecuteMetaData[StateOfTheArt.tex]{any}
\ExecuteMetaData[StateOfTheArt.tex]{none}

\subsection{Working With Multiple Indices}

We started by showing both the type and the implementation of each of our
examples. Although convenient at first to build an understanding of which
arguments are explicit and which ones are implicit, we are in the end only
interested in the way combinators let us write types. From now on, we
focus on the types and only the types of our examples.

The combinators presented earlier are all available in the standard library.
They work really well for unary predicates. Unfortunately they do not scale
beyond that. Meaning that if we are manipulating binary relations for
instance we have to partially the relations in question before we can use
our usual combinators. This leads to cluttered types which are not much better
than their fully expanded counterparts. For instance, assuming that \AF{\_≤\_}
is the usual order on natural numbers and \AF{\_≥\_} its converse, to state
that \AF{\_≤\_} is antisymmetric we have to write:

\ExecuteMetaData[StateOfTheArt.tex]{brokenantisym}

Ideally we could have used combinators similar to the ones for unary predicates
and have simply written:

\ExecuteMetaData[Examples.tex]{antisym}

We could naturally write a library for binary relations following the same
conventions as the one for unary predicates. However this will create two
new issues: first, the day we need a library for ternary relations, we have to
duplicate the work once again; second, we now have two sets of definitions
with conflicting them which cannot be both imported in the same module without
forcing users to manually disambiguate each use site.

\paragraph{Wish} We would like to define once and for all n-ary quantifiers,
and pointwise lifting of common type constructors.


\section{Getting Acquainted With the Unifier}

It is important to build an understanding of the way the unifier proceeds
to be able to write combinators usable with minimal user input.

Forgetting for a moment about level polymorphism, let us look at the first
wrong turn one may take. The type of an arbitrary function may be understood
as a list of \AF{Set}s (the successive domains) paired with a \AF{Set} (the
codomain). We can then compute the function's actual type as a \AF{foldr} on
the list.

\ExecuteMetaData[Broken.tex]{function}
\ExecuteMetaData[Broken.tex]{sem}



