\section*{Introduction}

For user convenience, Agda's standard library has accumulated a set of
equality-manipulating combinators of varying arities (Section~\ref{sec:nary2})
as well as a type-level compositional DSL to write clean types involving
indexed families of arity exactly one (Section~\ref{sec:unarycombinators}).
None of these solutions scale well. By getting acquainted with the unifier
(Section~\ref{sec:unifier}), we can design a good representation of n-ary
function spaces (Section~\ref{sec:naryfunction}) which empowers us to write
generalised combinators usable with minimal user input.

\section{N-ary Combinators... for N up to 2}\label{sec:nary2}

Agda's standard library relies on propositional equality defined as
a level polymorphic inductive family with one constructor \AIC{refl}.

\ExecuteMetaData[StateOfTheArt.tex]{equality}

As one would expect from a notion of equality, it is congruent (i.e.
for any function equal inputs yield equal outputs) and substitutive
(i.e. equals behave the same with respect to predicates). Concretely
this means we can write the two following functions by dependent
pattern-matching on the equality proof:

\ExecuteMetaData[StateOfTheArt.tex]{cong}
\ExecuteMetaData[StateOfTheArt.tex]{subst}

However we quickly realise that it is convenient to be able to use
congruence for functions which take more than one argument and
substitution for at least binary relations. The standard library
provides binary versions of both of these functions:

\ExecuteMetaData[StateOfTheArt.tex]{cong2}
\ExecuteMetaData[StateOfTheArt.tex]{subst2}

If we want to go beyond arity two however we are left to either define
our own ternary, quaternary, etc. versions of \AF{cong} and \AF{subst}
or awkwardly chaining the ones with a lower arity to slowly massage
the expression at hand into the shape we want. Both of these solutions
are unsatisfactory.

\paragraph{Wish} We would like to define once and for all two functions
\AF{congₙ} and \AF{substₙ} of respective types (pseudocode):

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{congₙ} : & (\AB{f} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B}) →\\
               & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
               & \AB{f} \AB{a₁} ⋯ \AB{aₙ} \AD{≡} \AB{f} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}
\medskip

\noindent\begin{tabular}{@{}l@{~}l}
  \AF{substₙ} : & (\AB{R} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AF{Set} \AB{r}) →\\
                & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ \AB{aₙ} \AD{≡} \AB{bₙ} → \\
                & \AB{R} \AB{a₁} ⋯ \AB{aₙ} → \AB{R} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}

\section{Invariant Respecting Programs}

A key feature of dependently typed languages is the ability to enforce
strong invariants in inductive families. As soon as the programmer starts
baking in these constraints, they need to write constraints-respecting
programs. Although a lot of programs are index-preserving, users need
to be painfully explicit about the index being threaded all across the
function's type.

\subsection{Working With Indexed Families}\label{sec:unarycombinators}

The standard library defines a set of handy combinators to talk about
indexed families without having to manipulate their index explicitly.
These form a compositional type-level DSL: each combinator has a very
specific semantics and putting them together builds an overall meaning.
A typical expression built using this DSL follows a fairly simple schema:
a combinator acting as a quantifier for the index surrounding a combination
of pointwise liftings of common type constructors.



The pointwise liftings of common type constructors mean the index is
threaded but we also have specialised combinators which either adjust
locally the value of the index, or quantify over it. This empowers
us to write lighter types which focus on the important predicates at
hand.

Before we can talk about concrete indexed families, describe these
various combinators, and demonstrate their usefulness, we need to
introduce the data the families will be indexed over. We pick \AD{List}
the level polymorphic type of lists parametrised by the type of their
elements as our running example.

\ExecuteMetaData[StateOfTheArt.tex]{list}

The most straightforward non-trivial indexed family we can define over
\AD{List} is the predicate lifting \AF{All} which ensures that a given
predicate \AB{P} holds of all the elements of a list. It has two
constructors which each bear the same name as their counterparts in the
underlying data: nil (\AIC{[]}) is a proof that all the elements in the
empty list satisfy \AB{P} and cons (\AIC{\_::\_}) is a proof that \AB{P}
holds of all the elements of a non-empty list if it holds of its head
and of all the elements in its tail.

\ExecuteMetaData[StateOfTheArt.tex]{all}

\subsubsection{Quantifiers}

We have two types of quantifiers: existential and universal. As they are
meant to \emph{surround} the indexed expression they are acting upon, we
define them as essentially pairs of brackets. The opening one is systematically
decorated with a mnemonic symbol: \AF{∃} for existential quantification,
\AF{Π} for explicit dependent quantification and \AF{∀} for implicit
universal quantification. Additionally we use chevrons for existential
quantifiers and square brackets for universal ones, recalling the operators
diamond and box of modal logic.

\paragraph{Existential Quantifier}\label{def:sigma} In type theory, existential
quantifiers are represented as dependent pairs. We introduce \AR{Σ}, a record
type of dependent pairs. They can be constructed using \AIC{\_,\_} and we can
project out the first and second component by using \ARF{proj₁} and \ARF{proj₂}
respectively.

\ExecuteMetaData[StateOfTheArt.tex]{sigma}

The existential quantifier for indexed families is defined as a special
case of \AR{Σ} which takes the index \AF{Set} implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{exists}

Using \AF{∃⟨\_⟩} we can write our first statement about an indexed family:
{(\AF{All} \AB{P})} is always satisfiable. That is to say that we can always
find a list (the empty one) for which it holds.

\ExecuteMetaData[StateOfTheArt.tex]{satisfiable}

\paragraph{Universal Quantifiers} The pendant of existential quantification
is universal quantification. In type theory this corresponds to a dependent
function space. Here we have room for variations and we can consider both
the explicit (\AF{Π[\_]}) \emph{and} the implicit (\AF{∀[\_]}) universal
quantifiers.

\ExecuteMetaData[StateOfTheArt.tex]{universal}
\ExecuteMetaData[StateOfTheArt.tex]{iuniversal}

Provided that a proposition holds of any value, we can prove it will hold
of any list of values by induction on such a list. Because we perform
induction on the list it is convenient to take it as an explicit argument
whereas the proof itself can take its argument implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{replicate}

\subsubsection{Pointwise Liftings}

Pointwise liftings for an index type \AB{I} are operators turning a type
constructor on \AF{Set}s into one acting on \AB{I}-indexed families by
threading the index. They are meant to be used partially applied so that
both their inputs and their output are \AB{I}-indexed, hence the mismatch
between their arity and the number of places for their arguments.

\paragraph{Implication} We start with the most used of all: implication
i.e. functions from proofs of one predicate to proofs of another.
\ExecuteMetaData[StateOfTheArt.tex]{implies}

The combinator \AF{\_⇒\_} associates to the right just like the type
constructor for functions does. We can write the analogue of sequential
application for applicative functors~\cite{DBLP:journals/jfp/McbrideP08}
like so:
\ExecuteMetaData[StateOfTheArt.tex]{ap}

\paragraph{Conjunction} To state that the conjunction of two predicates hold
we can use the pointwise lifting of pairing.

\ExecuteMetaData[StateOfTheArt.tex]{conjunction}

This enables to write functions which return more than one result. We can
for instance write the type of \AF{unzip}, the proof that if the conjunction
of \AB{P} and \AB{Q} holds of all the elements of a given list then both
\AB{P} and \AB{Q} in isolation hold of all of that list's elements.
\ExecuteMetaData[StateOfTheArt.tex]{unzip}

\paragraph{Negation}\todo{Pick pure vs distrib vs empty}

\ExecuteMetaData[StateOfTheArt.tex]{negation}
\ExecuteMetaData[StateOfTheArt.tex]{pure}
\ExecuteMetaData[StateOfTheArt.tex]{distrib}
\ExecuteMetaData[StateOfTheArt.tex]{empty}

\subsubsection{Adjustments to The Ambient Index}

Threading the index is only the least invasive of the modes of action
available to us. But we can also more actively interact with the ambient
index either by ignoring it completely, adjusting it using a function
or overwriting it entirely. We won't detail the last option as, as always,
overwriting is adjusting with a constant function.

\paragraph{Constant} Although we manipulate indexed families, some of
our function's arguments or its result may not depend on the index.
The \AF{const}ant indexed family is precisely what we need to represent
these cases.

\ExecuteMetaData[StateOfTheArt.tex]{const}

The erasure function taking a proof that \AB{P} holds of all a list's
elements to a list of pairs of elements and proofs that \AB{P} holds
of them is an instance where the return type is constant in the index.

\ExecuteMetaData[StateOfTheArt.tex]{toList}

\paragraph{Update} On the other end of the spectrum, we have operations
which update the ambient index using an abitrary function. The notation
\AF{\_⊢\_} is inspired by the convention in type theory to consider that
proofs in sequent calculus are written in an ambient context and that we
may use a turnstyle to describe the addition of newly-bound variables to
it.

\ExecuteMetaData[StateOfTheArt.tex]{update}

Stating that a function is compatible with \AF{All} is a typical use case
of such a combinator. If the function at hand is called \AF{f} then the
convention in the standard library is to call such a proof \AF{f⁺} as it
makes \AF{f} appear in the conclusion. We pick \AF{concat} (whose classic
definition is left out) in this concrete example.

\ExecuteMetaData[StateOfTheArt.tex]{join}

\subsection{Working With Multiple Indices}

We started by showing both the type and the implementation of each of our
examples. Although convenient at first to build an understanding of which
arguments are explicit and which ones are implicit, we are in the end only
interested in the way combinators let us write types. From now on, we
focus on the types and only the types of our examples.

The combinators presented earlier are all available in the standard library.
They work really well for unary predicates. Unfortunately they do not scale
beyond that. Meaning that if we are manipulating binary relations for
instance we have to partially apply the relations in question before we can
use our usual unary combinators. This leads to cluttered types which are not
much better than their fully expanded counterparts. For instance, assuming
that \AF{\_≤\_} is the usual order on natural numbers and \AF{\_≥\_} its
converse, to state that \AF{\_≤\_} is antisymmetric we have to write:

\ExecuteMetaData[StateOfTheArt.tex]{brokenantisym}

Ideally we could have used combinators similar to the ones for unary predicates
and have simply written:

\ExecuteMetaData[Examples.tex]{antisym}

We could duplicate the definitions for unary predicates and have equivalent
combinators for binary relations however this will create two new issues.
First, the day we need a library for ternary relations we will have triplicated
the initial work. Second, we would have two sets of definitions with identical
names meaning they cannot be both imported in the same module without clashing
thus forcing users to manually disambiguate each use site.

\paragraph{Wish} We would like to define once and for all n-ary quantifiers,
pointwise lifting of common type constructors, and adjustment functions.

\section{Plan} We can start to draw out the structure of our contribution now
that we have a good idea of the current state of the art, its limitation, and
the extension we want to see. Here are the key points we need to deliver:

\paragraph{Reified Types} We need to come up with a representation of n-ary
functions which is as general as possible: the domains should be allowed to
be different types, even types defined at different levels.

\paragraph{Semantics} We need to give a semantics taking a reified type and
computing its meaning as a \AF{Set} at some level which will also need to
be computed.

\paragraph{Invertible} The representation and its semantics should be unifier
friendly. That is to say that if using a combinators yields a constraint of
the form ``this type should be the result of evaluating the representation of
an n-ary function type'' then Agda should be able to reconstruct the
representation and discharge the constraints without any outside help.

\paragraph{Applications} Lastly we need to deliver the two wishes we
formulated earlier by actually implementing the n-ary versions of \AF{cong},
\AF{subst}, and the various combinators for manipulating indexed families.

\section{Getting Acquainted With the Unifier}\label{sec:unifier}

Unification is the process by which Agda reconstructs the values of the
implicit arguments the user was allowed to leave out. It bridges the gap
between the source program which should be convenient for humans to read,
write, and modify and the fully explicit terms in the internal syntax.

It is important to build a good understanding of the problems the unifier
can easily solve to be able to write combinators usable with minimal user
input.




\section{Representating N-ary Function Types}\label{sec:naryfunction}

Recall that a binary function type {\AB{A} → \AB{B} → \AB{C}} can also be seen
as a unary function type with codomain {\AB{B} → \AB{C}}. As a consequence there
is no hope for us to get Agda to build the representation we have in mind without
passing it at least a little bit of information. The least we can do is tell Agda
the arity of the function. From this single natural number we will compute the
shape of the whole representation.

Recall that unification is good at reconstructing values of types which have
η-rules. As a consequence, from the natural number \AB{n} passed to us as an
argument we are going to essentially compute a number of big right-nested
products.

\paragraph{Right-Nested Products} The two building blocks of right-nested
products are a binary product \AF{\_×\_} (defined as the non-dependent special
case of \AR{Σ} we saw in Section~\ref{def:sigma}) and the unit type
\AF{⊤} defined as a record with no field whatsoever.

\ExecuteMetaData[N-ary.tex]{unit}

Even though \AF{⊤} is defined as a \AF{Set}, we will sometimes need to use
it at a higher level. The usual solution is to manually lift it to the
appropriate level. Because \AR{Lift} is also a record, it will not get in the
way of reconstruction.

\ExecuteMetaData[N-ary.tex]{lift}

\paragraph{Level Polymorphism} To achieve fully general level polymorphism, we
need all the domains of our function type to be potentially at different levels.
Luckily the notion of \AF{Level} in Agda is a primitive \AF{Set} and we can thus
manipulate them just like any other values. In particular we can define containers
storing them. Our first definition called \AF{Levels} defines an \AB{n}-tuple of
\AF{Level}s by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{levels}

\paragraph{Heterogeneous Domains} Before we can generate the big right-nested
\AB{n}-tuple packaging the function's domains, we need to compute the level at
which it is going to live. The definition of \AR{Σ} makes clear that the product
of two types living respectively at level \AB{a} and \AB{b} sits at level
{(\AB{a} ⊔ \AB{b})} i.e. the least upper bound of \AB{a} and \AB{b}.
We define \AF{⨆} as the generalisation of the least upper bound operator
to {(\AF{Levels} \AB{n})} by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{tolevel}

Knowing that {(\AF{Set} \AB{a})} sits at level {(\AF{suc} \AB{a})}, it is
natural to declare that our \AB{n}-tuple of sets defined at various \AF{Levels}
will be defined at the sucessor of the generalised least upper bound of these
\AF{Levels}.

\ExecuteMetaData[N-ary.tex]{sets}

We can now encode an \AB{n}-ary function space as essentially a collection \AB{ls}
of {(\AF{Levels} \AB{n})} together with a corresponding \AB{n}-tuple of type
{(\AF{Sets} \AB{n} \AB{ls})} for the domain, and a level \AB{r} and a
{(\AF{Set} \AB{r})} for the codomain.

\paragraph{Semantics} We can give this encoding a semantics in a straightforward way
by induction on \AB{n} and case analysis on the {(\AF{Sets} \AB{n} \AB{ls})} argument.
A \AIC{zero}-ary function type is simply the codomain whilst a {(\AIC{suc} \AB{n})}-ary
one is a unary function type whose codomain is the \AB{n}-ary function type obtained
by induction hypothesis.

\ExecuteMetaData[N-ary.tex]{arrows}

Our first example is a \AN{2}-ary function: our favourite indexed family \AD{All}.

\ExecuteMetaData[Examples.tex]{all}
