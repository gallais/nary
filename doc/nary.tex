\section*{Introduction}

For user convenience, Agda's standard library has accumulated a set of
equality-manipulating combinators of varying arities (Section~\ref{sec:nary2})
as well as a type-level compositional DSL to write clean types involving
indexed families of arity exactly one (Section~\ref{sec:unarycombinators}).
None of these solutions scale well. By getting acquainted with the unifier
(Section~\ref{sec:unifier}), we can design a good representation of n-ary
function spaces (Section~\ref{sec:naryfunction}) which empowers us to write
generalised combinators (Sections \ref{sec:narycombinators} and \ref{sec:narycong})
usable with minimal user input. We then see how the notions introduced to
tackle our original motivations can be mobilised for other efforts in generic
programmig from an arity-generic zipWith to a direct style definition of printf.

\section{N-ary Combinators... for N up to 2}\label{sec:nary2}

Agda's standard library relies on propositional equality defined as
a level polymorphic inductive family with one constructor \AIC{refl}.

\ExecuteMetaData[StateOfTheArt.tex]{equality}

As one would expect from a notion of equality, it is congruent (i.e.
for any function equal inputs yield equal outputs) and substitutive
(i.e. equals behave the same with respect to predicates). Concretely
this means we can write the two following functions by dependent
pattern-matching on the equality proof:

\ExecuteMetaData[StateOfTheArt.tex]{cong}
\ExecuteMetaData[StateOfTheArt.tex]{subst}

However we quickly realise that it is convenient to be able to use
congruence for functions which take more than one argument and
substitution for at least binary relations. The standard library
provides binary versions of both of these functions:

\ExecuteMetaData[StateOfTheArt.tex]{cong2}
\ExecuteMetaData[StateOfTheArt.tex]{subst2}

If we want to go beyond arity two however we are left to either define
our own ternary, quaternary, etc. versions of \AF{cong} and \AF{subst}
or awkwardly chaining the ones with a lower arity to slowly massage
the expression at hand into the shape we want. Both of these solutions
are unsatisfactory.

\paragraph{Wish} We would like to define once and for all two functions
\AF{congₙ} and \AF{substₙ} of respective types (pseudocode):

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{congₙ} : & (\AB{f} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B}) →\\
               & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ → \AB{aₙ} \AD{≡} \AB{bₙ} → \\
               & \AB{f} \AB{a₁} ⋯ \AB{aₙ} \AD{≡} \AB{f} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}
\medskip

\noindent\begin{tabular}{@{}l@{~}l}
  \AF{substₙ} : & (\AB{R} : \AB{A₁} → ⋯ → \AB{Aₙ} → \AF{Set} \AB{r}) →\\
                & \AB{a₁} \AD{≡} \AB{b₁} → ⋯ → \AB{aₙ} \AD{≡} \AB{bₙ} → \\
                & \AB{R} \AB{a₁} ⋯ \AB{aₙ} → \AB{R} \AB{b₁} ⋯ \AB{bₙ}
\end{tabular}

\section{Invariant Respecting Programs}

A key feature of dependently typed languages is the ability to enforce
strong invariants in inductive families. As soon as the programmer starts
baking in these constraints, they need to write constraints-respecting
programs. Although a lot of programs are index-preserving, users need
to be painfully explicit about the index being threaded all across the
function's type.

\subsection{Working With Indexed Families}\label{sec:unarycombinators}

The standard library defines a set of handy combinators to talk about
indexed families without having to manipulate their index explicitly.
These form a compositional type-level Domain Specific Language (DSL):
each combinator has a precise semantics and putting them together builds
an overall meaning.

A typical expression built using this DSL follows a fairly simple schema:
a combinator acting as a quantifier for the index (Section~\ref{sec:quantifiers})
surrounds a combination of pointwise liftings of common type constructors
(Section~\ref{sec:liftings}), index updates (Section~\ref{sec:iupdates}),
and base predicates. This empowers us to write lighter types which hide
away the bits that are constant, focusing instead on the key predicates
and the changes made to the index.

Before we can talk about concrete indexed families, describe these
various combinators, and demonstrate their usefulness, we need to
introduce the data the families will be indexed over. We pick \AD{List}
the level polymorphic type of lists parametrised by the type of their
elements as our running example.

\ExecuteMetaData[StateOfTheArt.tex]{list}

The most straightforward non-trivial indexed family we can define over
\AD{List} is the predicate lifting \AF{All} which ensures that a given
predicate \AB{P} holds of all the elements of a list. It has two
constructors which each bear the same name as their counterparts in the
underlying data: nil (\AIC{[]}) is a proof that all the elements in the
empty list satisfy \AB{P} and cons (\AIC{\_::\_}) is a proof that \AB{P}
holds of all the elements of a non-empty list if it holds of its head
and of all the elements in its tail.

\ExecuteMetaData[StateOfTheArt.tex]{all}

\subsubsection{Quantifiers}\label{sec:quantifiers}

We have two types of quantifiers: existential and universal. As they are
meant to \emph{surround} the indexed expression they are acting upon, we
define them as essentially pairs of brackets. The opening one is systematically
decorated with a mnemonic symbol: \AF{∃} for existential quantification,
\AF{Π} for explicit dependent quantification and \AF{∀} for implicit
universal quantification. Additionally we use chevrons for existential
quantifiers and square brackets for universal ones, recalling the operators
diamond and box of modal logic.

\paragraph{Existential Quantifier}\label{def:sigma} In type theory, existential
quantifiers are represented as dependent pairs. We introduce \AR{Σ}, a record
type of dependent pairs. They can be constructed using \AIC{\_,\_} and we can
project out the first and second component by using \ARF{proj₁} and \ARF{proj₂}
respectively.\todo{def η}

\ExecuteMetaData[StateOfTheArt.tex]{sigma}

The existential quantifier for indexed families is defined as a special
case of \AR{Σ} which takes the index \AF{Set} implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{exists}

Using \AF{∃⟨\_⟩} we can write our first statement about an indexed family:
from the existence of a list such that \AB{P} holds of all its elements,
we can construct a list of pairs of elements and proofs that \AB{P} holds
for that value.

\ExecuteMetaData[StateOfTheArt.tex]{toList}

\paragraph{Universal Quantifiers} The pendant of existential quantification
is universal quantification. In type theory this corresponds to a dependent
function space. Here we have room for variations and we can consider both
the explicit (\AF{Π[\_]}) \emph{and} the implicit (\AF{∀[\_]}) universal
quantifiers.

\ExecuteMetaData[StateOfTheArt.tex]{universal}
\ExecuteMetaData[StateOfTheArt.tex]{iuniversal}

Provided that a proposition holds of any value, we can prove it will hold
of any list of values by induction on such a list. Because we perform
induction on the list it is convenient to take it as an explicit argument
whereas the proof itself can take its argument implicitly.

\ExecuteMetaData[StateOfTheArt.tex]{replicate}

\subsubsection{Pointwise Liftings}\label{sec:liftings}

Pointwise liftings for an index type \AB{I} are operators turning a type
constructor on \AF{Set}s into one acting on \AB{I}-indexed families by
threading the index. They are meant to be used partially applied so that
both their inputs and their output are \AB{I}-indexed, hence the mismatch
between their arity and the number of places for their arguments.

\paragraph{Implication} We start with the most used of all: implication
i.e. functions from proofs of one predicate to proofs of another.
\ExecuteMetaData[StateOfTheArt.tex]{implies}

The combinator \AF{\_⇒\_} associates to the right just like the type
constructor for functions does. We can write the analogue of sequential
application for applicative functors~\cite{DBLP:journals/jfp/McbrideP08}
like so:
\ExecuteMetaData[StateOfTheArt.tex]{ap}

\paragraph{Conjunction} To state that the conjunction of two predicates hold
we can use the pointwise lifting of pairing.

\ExecuteMetaData[StateOfTheArt.tex]{conjunction}

This enables us to write functions which return more than one result. We can
for instance write the type of \AF{unzip}, the proof that if the conjunction
of \AB{P} and \AB{Q} holds of all the elements of a given list then both
\AB{P} and \AB{Q} in isolation hold of all of that list's elements.

\ExecuteMetaData[StateOfTheArt.tex]{unzip}

Notice that we are using the conjunction combinator both on predicates ranging
over values and on ones ranging over lists of values.

\paragraph{Negation} Traditionally negation is defined as functions into
the empty type \AD{⊥}. We start by defining it together with its elimination
principle.

\begin{minipage}[t]{0.225\textwidth}
  \ExecuteMetaData[StateOfTheArt.tex]{bot}
\end{minipage}\begin{minipage}[t]{0.225\textwidth}
  \ExecuteMetaData[StateOfTheArt.tex]{botelim}
\end{minipage}

Negation for a unary predicate \AB{P} is then the unary predicate which to
each \AB{i} associates {(\AB{P} \AB{i} → ⊥)}.

\ExecuteMetaData[StateOfTheArt.tex]{negation}

Our use case requires the introduction of \AD{Any}, the other classic
predicate lifting on list. It takes a predicate and ensures that it
holds of at least one element of the list at hand. Either it holds of
the first one and we are given a proof (\AIC{here}) or it holds of a
value somewhere in the tail (\AIC{there}).

\ExecuteMetaData[StateOfTheArt.tex]{any}

These two predicate liftings interact in non-trivial ways. For instance
if we know that the negation of \AB{P} holds of any value in a given
list then \AB{P} can't hold of all its elements. In other words: a single
counter-example is enough to disprove a universal statement.

\ExecuteMetaData[StateOfTheArt.tex]{anynotall}

Notice that we are once more using the combinator we just defined both on
a predicate on values and one on lists of values.

\subsubsection{Adjustments to The Ambient Index}\label{sec:iupdates}

Threading the index is only the least invasive of the modes of action
available to us. But we can also more actively interact with the ambient
index either by ignoring it completely, adjusting it using a function
or overwriting it entirely. We won't detail the last option as, as always,
overwriting is adjusting with a constant function.

\paragraph{Constant} Although we manipulate indexed families, some of
our function's arguments or its result may not depend on the index.
The \AF{const}ant indexed family is precisely what we need to represent
these cases.

\ExecuteMetaData[StateOfTheArt.tex]{const}

We can for instance prove that if the constantly false predicate
{(\AF{const} \AF{⊥})} holds true of all the elements of a list then
said list is the empty list. We use a section (i.e. a partially applied
infix operator) of propositional equality to formulate that conclusion.

\ExecuteMetaData[StateOfTheArt.tex]{empty}

Note that we had to add a type annotation to \AIC{[]}: \AF{const}'s
domain is an implicit polymorphic argument and so is the type of elements
in \AD{List}'s nil constructor. Agda can figure out that these two implicit
arguments are equal but needs to be given enough information to figure out
what it ought to be. In type theory, an identity function is a fine
definition of a type annotation operator:

\ExecuteMetaData[StateOfTheArt.tex]{annot}

\paragraph{Update} On the other end of the spectrum, we have operations
which update the ambient index using an abitrary function. The notation
\AF{\_⊢\_} is inspired by the convention in type theory to consider that
proofs in sequent calculus are written in an ambient context and that we
may use a turnstyle to describe the addition of newly-bound variables to
it.

\ExecuteMetaData[StateOfTheArt.tex]{update}

Stating that a function is compatible with \AF{All} is a typical use case
of such a combinator. If the function at hand is called \AF{f} then the
convention in the standard library is to call such a proof \AF{f⁺} as it
makes \AF{f} appear in the conclusion. We pick \AF{concat} (whose classic
definition is left out) in this concrete example.

\ExecuteMetaData[StateOfTheArt.tex]{join}

\subsection{Working With Multiple Indices}

We started by showing both the type and the implementation of each of our
examples. Although convenient at first to build an understanding of which
arguments are explicit and which ones are implicit, we are in the end only
interested in the way combinators let us write types. From now on, we
focus on the types and only the types of our examples.

The combinators presented earlier are all available in the standard library.
They work really well for unary predicates. Unfortunately they do not scale
beyond that. Meaning that if we are manipulating binary relations for
instance we have to partially apply the relations in question before we can
use our usual unary combinators. This leads to cluttered types which are not
much better than their fully expanded counterparts. For instance, assuming
that \AF{\_≤\_} is the usual order on natural numbers and \AF{\_≥\_} its
converse, to state that \AF{\_≤\_} is antisymmetric we have to write:

\ExecuteMetaData[StateOfTheArt.tex]{brokenantisym}

Ideally we could have used combinators similar to the ones for unary predicates
and have simply written:

\ExecuteMetaData[Examples.tex]{antisym}

We could duplicate the definitions for unary predicates and have equivalent
combinators for binary relations however this will create two new issues.
First, the day we need a library for ternary relations we will have triplicated
the initial work. Second, we would have two sets of definitions with identical
names meaning they cannot be both imported in the same module without clashing
thus forcing users to manually disambiguate each use site.

\paragraph{Wish} We would like to define once and for all n-ary quantifiers,
pointwise lifting of common type constructors, and adjustment functions.

\section{Plan} We can start to draw out the structure of our contribution now
that we have a good idea of the current state of the art, its limitation, and
the extension we want to see. Here are the key points we need to deliver:

\paragraph{Reified Types} We need to come up with a representation of n-ary
functions which is as general as possible: the domains should be allowed to
be different types, even types defined at different levels.

\paragraph{Semantics} We need to give a semantics taking a reified type and
computing its meaning as a \AF{Set} at some level which will also need to
be computed.

\paragraph{Invertible} The representation and its semantics should be unifier
friendly. That is to say that if using a combinators yields a constraint of
the form ``this type should be the result of evaluating the representation of
an n-ary function type'' then Agda should be able to reconstruct the
representation and discharge the constraints without any outside help.

\paragraph{Applications} Lastly we need to deliver the two wishes we
formulated earlier by actually implementing the n-ary versions of \AF{cong},
\AF{subst}, and the various combinators for manipulating indexed families.

\section{Getting Acquainted With the Unifier}\label{sec:unifier}

Unification is the process by which Agda reconstructs the values of the
implicit arguments the user was allowed to leave out. It is one of the
mechanisms bridging the gap between the source program which should be
convenient for humans to read, write, and modify and the fully explicit
terms in the internal syntax.

It is important to build a good understanding of the problems the unifier
can easily solve to be able to write combinators usable with minimal user
input. Indeed if we can anticipate that an argument can be reconstructed,
we may as well make it implicit and let Agda do the work.

\paragraph{Notations} We write \AB{?a} for a
metavariable, \AB{e}[\AB{?a₁}, ⋯ ,\AB{?aₙ}] for an expression \AB{e}
containing exactly the metavariables \AB{?a₁} to \AB{?aₙ},
\AB{c} \AB{e₁} ⋯ \AB{eₙ} for the constructor \AB{c} applied to \AB{n}
expressions and {\AB{lhs} ≈ \AB{rhs}} to state a unification problem
between two expressions \AB{lhs} and \AB{rhs}.

\paragraph{Unification Tests} We can easily trigger the resolution of
unification problems by writing unit tests in the source language. We can
force Agda to introduce metavariables by using an underscore (\AF{\_}) as a
placeholder for a subterm and use \AIC{refl} at the proof of a propositional
equality to force it to unify the two expressions stated to be equal. For
instance in the following test we force Agda to check that
{(\AB{?A} → \AB{?B}) ≈ (\AD{ℕ} → \AD{ℕ})}.

\ExecuteMetaData[Unifier.tex]{unifproblem}

Whenever Agda cannot solve a metavariable by unification it is highlighted
in yellow like so: \AgdaUnsolvedMeta{\_}. Whenever Agda cannot satisfy a
unification constraint raised by the use of \AIC{refl}, it will also highlight
it in yellow like so: \AgdaUnsolvedConstraint{\AIC{refl}}.

Let us now look at the various scenarii in which it is easy for the unifier
to decide whether a constraint is satisfiable.

\subsection{Instantiation}

The simplest case the unifier can encounter is a problem of the form
{\AB{?a} ≈ \AB{e}[\AB{?a₁} ⋯ \AB{?aₙ}]} where \AB{?a} does not appear
in the list {[\AB{?a₁}, ⋯ ,\AB{?aₙ}]}. The unifier can simply instantiate
the metavariable to the candidate expression.

For instance in the following test you can see that neither the underscore
on the left-hand side nor the \AIC{refl} constructor is highlighted in yellow.
Meaning that the metavariable on the left was indeed solved (by instantiating
it to the expression on the right-hand side) and that the constraint induced
by the use of \AIC{refl} was thus satisfied. The problem itself is
under-constrained so it is not surprising that the right-hand side lights up.

\ExecuteMetaData[Unifier.tex]{instantiation}

\subsection{Constructor Headed}

The second case where the unifier can easily make progress is a unification
problem between to constructor-headed expression
{\AB{c} \AB{e₁} ⋯ \AB{eₘ} ≈ \AB{d} \AB{f₁} ⋯ \AB{fₙ}}.

\paragraph{Success} Either the constructors \AB{c} and \AB{d} match up, we learn
that \AB{m} equals \AB{n} and we can reduce the problem to unifying their
respective arguments by forming the new unification problems
{(\AB{e₁} ≈ \AB{f₁}) ⋯ (\AB{eₘ} ≈ \AB{fₙ})}.

In the following example, Agda sees that both expressions have {\_→\_} as their
head constructor, proceeds to unify \AD{ℕ} with itself on the one hand (which
succeeds because both have the same head constructor and they do not have any
arguments) and \AD{ℕ} with \AB{?A} on the other (which succeeds by instantiation).

\ExecuteMetaData[Unifier.tex]{unifconstr}

\paragraph{Failure} Or \AB{c} and \AB{d} are distinct and we can immediately
conclude that unification is impossible. We cannot write an expression in Agda
demonstrating this case as it leads to a type error in the language.
Trying to form the unification problem {\AD{ℕ} ≈ (\AB{\_} → \AB{\_})} would
raise such an error because \AD{ℕ} and {\_→\_} are distinct head constructors.

\subsection{Avoid Computations...}

In general unification problems involving computations are undecidable.
We can easily construct a total simulation function \AF{sim} for Turing
machines which takes in as arguments the code for an arbitrary program \AB{prg}
and a natural number \AB{n} and returns \AN{0} if and only if the program runs
for exactly \AB{n} steps before stopping and \AN{1} otherwise. Forming a
constraint like {\AF{sim} \AB{prg} \AB{\_} ≈ \AN{0}} is effectively asking
whether the program \AB{prg} terminates. It is clearly impossible to write a
unifier solving all problems of this form.



\subsection{... In Most Cases}\label{sec:unifiermagic}

Although unification problems mentioning computations will in general fail
to produce solutions, there are exceptions.


\paragraph{Disappearing Problem} The first favourable case is a Lapalissade:
stuck function applications which are guaranteed to go away in all cases of
interest to us are never a problem. This is true whenever we know that in all
use cases the concrete values at hand will allow evaluation to reveal enough
constructors for unification to succeed.

To demonstrate this phenomenon we introduce a type \AF{nary} of \AB{n}-ary
functions on natural numbers. It is parametrised by the return type of the
\AB{n}-ary function and defined by induction \AB{n}.

\ExecuteMetaData[Unifier.tex]{nary}

In general, it is impossible to solve the unification constraint
{\AF{nary} \AB{?n} \AB{?A}} ≈ {(\AD{ℕ} → \AB{A})}. If the natural
number is not specified then \AF{nary} is stuck. And there is no
hope to solve this problem; indeed there are two solutions because
every unary function is also a nullary symbol whose type is a function
type. As explained earlier, Agda communicates to us this failure to solve
the two metavariables passed to \AF{nary} as arguments by highlighting them
in yellow, \AIC{refl} is also highlighted as the source of the unification
constraint which could not be satisfied.

\ExecuteMetaData[Unifier.tex]{unsolved}

If the natural number argument is however a concrete value then \AF{nary}
evaluates fully and Agda is able to reconstruct \AB{A} by unification. In
the following two examples we unify {(\AD{ℕ} → \AD{ℕ})} with {(\AD{ℕ} → \AB{?A})}
on the one hand and {\AB{?A}} on the other. Both unification problems succed
without any issue.

\begin{minipage}{0.225\textwidth}
  \ExecuteMetaData[Unifier.tex]{normalised1}
\end{minipage}\begin{minipage}{0.225\textwidth}
  \ExecuteMetaData[Unifier.tex]{normalised0}
\end{minipage}

This observation is language independent. It will directly influence our
encoding: we expect our users to only ever use our generic congruence
combinator with concrete arities. A representation defined by induction
on such a natural number would therefore work well with the unifier.

\paragraph{Invertible Problem} The second case in which we may have
unification problems involving stuck computations and still see Agda
find a solution is more language dependent but just as principled.
Whenever the stuck function is defined by a set of equations whose
right-hand sides are clearly anti-unifiable, we can invert it.

For instance if the \AF{Set} parameter to \AF{nary} is known to be
\AD{ℕ} then the right-hand side of the first equation is \AD{ℕ} and
the second's one has the shape {(\AD{ℕ} → \_)}. These two are clearly
disjoint and so Agda can invert \AF{nary} and figure out that the
arity we left out is \AN{1}.

\ExecuteMetaData[Unifier.tex]{inverted}

If we had passed {(\AD{ℕ} → \AD{ℕ})} instead then the two right-hand
sides would not have been obviously disjoint and Agda would have given
up on trying to invert \AF{nary}.

\ExecuteMetaData[Unifier.tex]{notinverted}

These two examples tell us that we can hope to leave out a function's
arity entirely if we statically know its codomain and it has a shape
clearly anti-unifiable with the right-hand sides of our semantics of
reified function types. Note in particular that combinators acting
on relations (cf. Section~\ref{sec:unarycombinators}) are manipulating
functions whose codomain is always of the shape {(\AF{Set} \_)} which
is clearly disjoing from {(\_ → \_)}. We ought to be able to define
their \AB{n}-ary counterparts without having to mention \AB{n} explicitly.

\section{Representating N-ary Function Types}\label{sec:naryfunction}

\todo{rewrite}
Recall that a binary function type {\AB{A} → \AB{B} → \AB{C}} can also be seen
as a unary function type with codomain {\AB{B} → \AB{C}}. As a consequence in
the general case there is no hope for us to get Agda to build the representation
we have in mind without passing it at least a little bit of information.
The least we can do is tell Agda the arity of the function. From this single
natural number we will compute the shape of the whole representation.

Recall that unification is good at reconstructing values of types which have
η-rules\todo{fix}. As a consequence, from the natural number \AB{n} passed to us as an
argument we are going to essentially compute a number of big right-nested
products.

\paragraph{Right-Nested Products} The two building blocks of right-nested
products are a binary product \AF{\_×\_} (defined as the non-dependent special
case of \AR{Σ} we saw in Section~\ref{def:sigma}) and the unit type
\AF{⊤} defined as a record with no field whatsoever.

\ExecuteMetaData[N-ary.tex]{unit}

Even though \AF{⊤} is defined as a \AF{Set}, we will sometimes need to use
it at a higher level. The usual solution is to manually lift it to the
appropriate level. Because \AR{Lift} is also a record, it will not get in the
way of reconstruction.

\ExecuteMetaData[N-ary.tex]{lift}

\paragraph{Level Polymorphism} To achieve fully general level polymorphism, we
need all the domains of our function type to be potentially at different levels.
Luckily the notion of \AF{Level} in Agda is a primitive \AF{Set} and we can thus
manipulate them just like any other values. In particular we can define containers
storing them. Our first definition called \AF{Levels} defines an \AB{n}-tuple of
\AF{Level}s by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{levels}

\paragraph{Heterogeneous Domains} Before we can generate the big right-nested
\AB{n}-tuple packaging the function's domains, we need to compute the level at
which it is going to live. The definition of \AR{Σ} makes clear that the product
of two types living respectively at level \AB{a} and \AB{b} sits at level
{(\AB{a} ⊔ \AB{b})} i.e. the least upper bound of \AB{a} and \AB{b}.
We define \AF{⨆} as the generalisation of the least upper bound operator
to {(\AF{Levels} \AB{n})} by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{tolevel}

Knowing that {(\AF{Set} \AB{a})} sits at level {(\AF{suc} \AB{a})}, it is
natural to declare that our \AB{n}-tuple of sets defined at various \AF{Levels}
will be defined at the sucessor of the generalised least upper bound of these
\AF{Levels}.

\ExecuteMetaData[N-ary.tex]{sets}

We can now encode an \AB{n}-ary function space as essentially a collection \AB{ls}
of {(\AF{Levels} \AB{n})} together with a corresponding \AB{n}-tuple of type
{(\AF{Sets} \AB{n} \AB{ls})} for the domains, and a level \AB{r} and a
{(\AF{Set} \AB{r})} for the codomain.

\paragraph{Semantics}\label{sec:semantics}
We can give this encoding a semantics in a straightforward
way by induction on \AB{n} and case analysis on the {(\AF{Sets} \AB{n} \AB{ls})}
argument. A \AIC{zero}-ary function type is simply the codomain whilst a
{(\AIC{suc} \AB{n})}-ary one is a unary function type whose codomain is the
\AB{n}-ary function type obtained by induction hypothesis.

\ExecuteMetaData[N-ary.tex]{arrows}

If we look carefully at this definition we can notice that the function
\AF{Arrows} may only ever get stuck if the natural number is not concrete.
Even though we do take the \AF{Sets} argument apart, it has a product type
and thus enjoys η-rules.

Our first example is a \AN{2}-ary function: our favourite indexed family \AD{All}.
The last element of the telescope, a value whose type is a lifted version of the
unit type, can be inferred by Agda so we leave it out.

\ExecuteMetaData[Examples.tex]{all}

\section{Combinators for Indexed Families}\label{sec:narycombinators}

\subsection{Quantifiers}\todo{}

\ExecuteMetaData[N-ary.tex]{quantify}

\ExecuteMetaData[N-ary.tex]{ex}

\ExecuteMetaData[N-ary.tex]{iall}
\ExecuteMetaData[N-ary.tex]{all}

\subsection{Pointwise liftings}

Pointwise lifting of a binary function can be defined uniformly for any
operation of type {(\AB{A} → \AB{B} → \AB{C})} and any pair of \AB{n}-ary
functions whose domains match and codomains are respectively \AB{A} and
\AB{B}. It is defined by induction on the arity \AB{n} of the input functions.

\ExecuteMetaData[N-ary.tex]{lift2}

From this very general definition we can recover the combinators we are
used to. For each one of them we are able to leave out the arity argument
thanks to the observation we made in Section~\ref{sec:unifiermagic}: \AF{Set}
and {(\AB{?A} → \AB{?B}) are anti-unifiable and Agda is therefore able to
reconstruct the arity for us!

Implication is the lifting of the function space.

\ExecuteMetaData[N-ary.tex]{implication}

Conjunction is the lifting of pairing.

\ExecuteMetaData[N-ary.tex]{conjunction}

Disjunction is the lifting of the sum type.

\ExecuteMetaData[N-ary.tex]{disjunction}

Negation is obviously not a binary operation. In practice, rather than
having multiple ad-hoc lifting functions for various arities we have a
fully generic \AF{liftₙ} functional which lifts a \AB{k}-ary operator
to work with \AB{k} \AB{n}-ary functions whose respective codomains
match the domains of the operator. Its type could be summarised as:

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{liftₙ} : & ∀ k n.\\
               & (\AB{B₁} → ⋯ → \AB{Bₖ} → \AB{B}) →\\
               & (\AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B₁}) →\\
               \multicolumn{2}{c}{\vdots} \\
               & (\AB{A₁} → ⋯ → \AB{Aₙ} → \AB{Bₖ}) →\\
               & (\AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B})\\
\end{tabular}
\medskip

The thus generalised definition has a fairly unreadable type so we leave
this formal definition out of the paper. Curious readers can consult the
accompanying code.

\ExecuteMetaData[N-ary.tex]{negation}


\section{Congruence and Substitution}\label{sec:narycong}

So far the types we have ascribed our combinators for \AB{n}-ary relations
where fairly tame. Things get a bit more complicated when dealing with
congruence and substitution: we won't be able to write these functions' types
directly. Both definitions follow the same structure: we start by computing
the operation's type by induction and we can then implement the operation itself.

\subsection{Congruence}

The type of congruence mentions only one function. However it is applied to two
distinct lists of values to form the left-hand side and the right-hand side of
the conclusion. As a consequence when we compute the type we take two functions
as inputs.

Congruence for two \AN{0}-ary functions collapses to simply propositional equality
of the two constant values.

Congruence for two (\AIC{suc} \AB{n})-ary functions \AB{f} and \AB{g} amounts to
stating that for any pair of equal values \AB{x} and \AB{y} we expect that
{(\AB{f} \AB{x})} and {(\AB{g} \AB{y})} are congruent.

\ExecuteMetaData[N-ary.tex]{Cong}

The congruence lemma is then obtained by stating that the \AB{n}-ary function \AB{f}
is congruent with itself. We prove it by induction on \AB{n}, pattern-matching on the
proofs of equality as we go along.

\ExecuteMetaData[N-ary.tex]{cong}

\subsection{Substitution}

The definition of \AF{Substₙ} is identical to that of \AF{Congₙ} except for the
base case: instead of \AB{f} and \AB{g} being two values, they are two \AF{Set}s.
We demand a function transporting values in \AB{f} to ones \AB{g}.

\ExecuteMetaData[N-ary.tex]{Subst}

Substitution acts on \AB{n}-ary relations. Recalling our observation made
in Section~\ref{sec:unifiermagic} that Agda can easily reconstruct the arity
of \AF{Set}-valued functions, we can make \AB{n} an implicit argument.

\ExecuteMetaData[N-ary.tex]{subst}



\section{Further Generic Programming Efforts}

The small language we have developped to talk about \AB{n}-ary functions can
be used beyond our first few motivating examples of congruence, substitution,
and combinators to define relations. We detail in this section various results
which fall out naturally from this work. We start with generic (un)currying
which we can then use to define an \AB{n}-ary \AF{zipWith} and revisit
\AF{printf} in direct style.

\subsection{Product and (Un)Currying}

We gave in Section~\ref{sec:semantics} a semantics to our reified types as
proper \AB{n}-ary function types. We can alternatively interpret a \AF{Sets}
as a big right-nested and \AR{⊤}-terminated product containing one value for
each \AF{Set}. We once more proceed by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{product}

We can convert back and forth between a unary function whose domain is a
\AF{Product} of \AF{Sets} and an \AB{n}-ary function whose domains are the
same sets. These conversion functions correspond to currying and uncurrying.
Both \AF{curryₙ} and \AF{uncurryₙ} are implemented by structural induction
on \AB{n} and in terms of their binary counterparts.

\ExecuteMetaData[N-ary.tex]{curry}
\ExecuteMetaData[N-ary.tex]{uncurry}

\paragraph{\AR{⊤}-free Variant} In practice users do not tend to write
\AR{⊤}-terminated right-nested products. As a consequence it is convenient
to have a definition of \AF{Product} which has a special case for \AF{Sets}
of size exactly \AN{1} returning the \AF{Set} without pairing it with \AR{⊤}.
This makes \AF{curryₙ} and \AF{uncurryₙ} more useful overall. Most generic
functions however are easier to implement using the \AR{⊤}-terminated version
of \AF{Product}. We provide both as well as conversion functions from one to
the other.

\subsection{N-ary Zipping Functions}

Some functions are easier to write curried but nicer to use uncurried.
This is the case with \AF{zipWithₙ}, the \AB{n}-ary version of the
higher-order function which takes a function and two lists as inputs
and produces a list by processing both lists in lockstep and using the
function it was passed to combine their elements. Using ellipses, we would
write its type as:

\medskip
\noindent\begin{tabular}{@{}l@{~}l}
  \AF{zipWithₙ} : & ∀ n. (\AB{A₁} → ⋯ → \AB{Aₙ} → \AB{B}) →\\
                  & \AD{List} \AB{A₁} → ⋯ → \AD{List} \AB{Aₙ} → \AD{List} \AB{B}
\end{tabular}
\medskip

To formally write this type, we need to explain how to map a level polymorphic
endofunctor on \AF{Set} (here: \AD{List}) over a {(\AF{Sets} \AB{n} \AB{ls})}.
We proceed by induction on \AB{n}.

\ExecuteMetaData[N-ary.tex]{smap}

As explained earlier it is vastly easier to implement the function using
the uncurried type, and to then recover the desired type by invoking generic
(un)currying in the appropriate places. The function we want is therefore
implemented in term of an auxiliary definition called \AF{zw-aux}.

\ExecuteMetaData[N-ary.tex]{zipWith}

\paragraph{Implementation} The auxiliary definition is still a bit involved
so we detail each equation of its definition below. We start with its type
first.

\ExecuteMetaData[N-ary.tex]{zw-aux-type}

When \AB{n} is \AN{0}, an Haskeller would typically return an infinite list
containing the value \AB{f} repeated. However this is not possible in Agda,
a total language~\cite{DBLP:journals/jucs/ATurner04}: all the lists have to
be finite. Our only option is to return the empty one.

\ExecuteMetaData[N-ary.tex]{zw-aux0}

When \AB{n} is \AN{1} we can get our hands on a function \AB{f} of type
{((\AB{A} \AR{×} \AR{⊤}) → \AB{R})} and a {\AD{List} \AB{A}} and we need to
return a {\AD{List} \AB{R}}. We can \AF{map} the (tweaked) function over the
list.

\ExecuteMetaData[N-ary.tex]{zw-aux1}

The meat of the definition is in the last case: we are given a function
{((\AB{A} \AR{×} \AB{A₀} \AR{×} ⋯ \AR{×} \AB{Aₙ}) → \AB{R})}, a list of \AB{A}s
and a product of lists {(\AD{List} \AB{A₀} \AR{×} ⋯ \AR{×} \AD{List} \AB{Aₙ})}.
We massage the function to obtain another one of type
{((\AB{A₀} \AR{×} ⋯ \AR{×} \AB{Aₙ}) → (\AB{A} → \AB{R}))} which we can
combine with the product of lists thanks to our induction hypothesis. This gives
us back a list of functions of type {(\AB{A} → \AB{R})}. We can conclude thanks
to the usual binary \AF{zipWith} to combine this list of functions with the list
of arguments we had already.

\ExecuteMetaData[N-ary.tex]{zw-auxn}

\subsection{Printf}

The definitions we have introduced also make it easy to implement \AF{Printf}
in direct style as opposed to the classic accumulator-based
definition~\cite{DBLP:conf/icfp/Augustsson98}. We work in a
simplified setting which allows us to focus on the contribution our \AB{n}-ary
combinators bring to the table. Our \AF{printf} will only take natural numbers
as arguments and we will worry about defining the lexer transforming a raw
string into a \AF{Format}, that is to say a list of \AD{Chunk}s (each being
either a \AIC{Nat} corresponding to a ``\%u'' directive, or a \AIC{Raw} string).

\ExecuteMetaData[Printf.tex]{chunk}

Our notion of \AF{Format} is not intrinsically sized but we do need to know
how many arguments our \AF{printf} function is going to take if we want to use
the machinery for \AB{n}-ary functions. We assume the existence of a \AF{size}
function counting the number of \AIC{Nat} in a \AF{Format}. We also assume the
existence of \AF{0ℓs}, a (\AF{Levels} \AB{n}) equal to \AF{0ℓ} everywhere. Using
these we can give \AF{Format} a semantics as a \AF{Sets}:

\ExecuteMetaData[Printf.tex]{format}

The essence of \AF{printf} is then given by a function \AF{assemble} which
collects a list of strings from various sources. Whenever the format expects
a natural number, we know we got one as an input and can \AF{show} it.
Otherwise the raw string to use is specified in the \AF{Format} itself.

\ExecuteMetaData[Printf.tex]{assemble}

The toplevel function itself is obtained by currying the composition of
\AF{concat} and \AF{assemble}.

\ExecuteMetaData[Printf.tex]{printf}

We can check on an example that we do get a function with the appropriate
type when we use a concrete \AF{Format}. And that it does produce the
expected string when run on arguments.

\ExecuteMetaData[Printf.tex]{example}

\section{Conclusion and Future Work}

We have seen that Agda's standard library defines a useful type-level
domain specific language to manipulate unary predicates.\todo{contribs}

The notions introduced to set the stage for the definition of \AB{n}-ary
versions of these combinators were already powerful enough to allow us
to revisit classic dependently typed traversals.


\paragraph{Telescopes} The lack of dependencies between the various domains
and the codomain of our \AF{Arrows} is flagrant. A natural question to ask
is how much of this machinery can be generalised to telescopes rather than
mere \AF{Sets} without incurring any additional burden on the user. From
experience we know that it is sometimes wise to explicitly use the
non-dependent version of an operator (e.g. function composition) to inform
Agda's unifier that it is only looking for a solution in a restricted
subset.

\paragraph{Datatype genericity} Our implementation of an \AB{n}-ary version of
\AF{zipWith} started as drive-by generic programming, demonstrating that the
notions introduced for our purposes could be useful in a more general context.
Previous efforts in dependently typed programming such as Weirich and
Casinghino~\cite{DBLP:conf/plpv/WeirichC10} work on not only arity-generic
but also datatype-generic programming suggest we may push this further.
Their solution predates universe polymorphism and although the traversals
are adequatly heterogeneous, their approach would not scale to universe
polymorphic functions.
